#!/bin/bash
source "sEncfs.sh"
 UNMARK(){ $e "\e[0m";}
 MARK(){ $e "\e[1;37m";}
#
 HEAD()
{
 for (( a=2; a<=26; a++ ))
  do
   TPUT $a 1
    $E "$na";
  done
 TPUT  1 1;$E "$nb";UNMARK;
 TPUT  2 2;$E "\e[36m Функция вывода ключей\e[0m                                 \e[36m Key Derivation Function\e[0m";
 TPUT  3 1;$E "$nc";
 TPUT  4 2;$E "\e[2m Начиная с версии 1.5, EncFS теперь использует PBKDF2 в качестве функции полу-\e[0m"
 TPUT  5 2;$E "\e[2m чения ключа по умолчанию. Количество итераций в функции ключа выбирается на\e[0m"
 TPUT  6 2;$E "\e[2m основе времени настенных часов для генерации ключа. В стандартном режиме ис-\e[0m"
 TPUT  7 2;$E "\e[2m пользуется целевое время 0,5 секунды, а в режиме паранойи используется целевое\e[0m"
 TPUT  8 2;$E "\e[2m время 3,0 секунды. В системе AMD 64 с частотой 1,6 ГГц примерно 64 000 итера-\e[0m"
 TPUT  9 2;$E "\e[2m ций функции получения ключа можно выполнить за полсекунды. Точное количество\e[0m"
 TPUT 10 2;$E "\e[2m используемых итераций хранится в файле конфигурации, так как оно необходимо\e[0m"
 TPUT 11 2;$E "\e[2m для перемонтирования файловой системы. Если конфигурация файловой системы\e[0m"
 TPUT 12 2;$E "\e[2m EncFS из 1.4.x изменена с помощью версии 1.5 (например, при использовании\e[0m"
 TPUT 13 2;$E "\e[2m encfsctl для изменения пароля), то будет использоваться новая функция PBKDF2,\e[0m"
 TPUT 14 2;$E "\e[2m и файловая система больше не будет доступна для чтения более старыми версиями.\e[0m";
 TPUT 15 1;$E "$nc";
 TPUT 25 1;$E "$nd";
}
 FOOT(){ MARK;TPUT 27 1;$E "$ne";UNMARK;}
#
  M0(){ TPUT 16 3; $e "Шифр                                                                 \e[32m Cipher \e[0m";}
  M1(){ TPUT 17 3; $e "Размер ключа шифра                                          \e[32m Cipher Key Size \e[0m";}
  M2(){ TPUT 18 3; $e "Размер блока файловой системы                         \e[32m Filesystem Block Size \e[0m";}
  M3(){ TPUT 19 3; $e "Кодировка имени файла                                     \e[32m Filename Encoding \e[0m";}
  M4(){ TPUT 20 3; $e "Цепочка инициализации имени файла   \e[32m Filename Initialization Vector Chaining \e[0m";}
  M5(){ TPUT 21 3; $e "Векторы инициализации файлов                \e[32m Per-File Initialization Vectors \e[0m";}
  M6(){ TPUT 22 3; $e "Внешняя цепочка IV                                     \e[32m External IV Chaining \e[0m";}
  M7(){ TPUT 23 3; $e "Блокировать заголовки MAC                                 \e[32m Block MAC headers \e[0m";}
  M8(){ TPUT 24 3; $e "Сквозное отверстие для напильника                    \e[32m File-hole pass-through \e[0m";}
#
  M9(){ TPUT 26 3; $e "Exit                                                                         ";}
LM=9
   MENU(){ for each in $(seq 0 $LM);do M${each};done;}
    POS(){ if [[ $cur == up ]];then ((i--));fi
           if [[ $cur == dn ]];then ((i++));fi
           if [[ $i -lt 0   ]];then i=$LM;fi
           if [[ $i -gt $LM ]];then i=0;fi;}
REFRESH(){ after=$((i+1)); before=$((i-1))
           if [[ $before -lt 0  ]];then before=$LM;fi
           if [[ $after -gt $LM ]];then after=0;fi
           if [[ $j -lt $i      ]];then UNMARK;M$before;else UNMARK;M$after;fi
           if [[ $after -eq 0 ]] || [ $before -eq $LM ];then
           UNMARK; M$before; M$after;fi;j=$i;UNMARK;M$before;M$after;}
   INIT(){ R;HEAD;FOOT;MENU;}
     SC(){ REFRESH;MARK;$S;$b;cur=`ARROW`;}
# Функция возвращения в меню
     ES(){ MARK;$e " ENTER = main menu ";$b;read;INIT;};INIT
  while [[ "$O" != " " ]]; do case $i in
  0) S=M0;SC; if [[ $cur == enter ]];then R;echo -e "
 Какой алгоритм шифрования использовать.
 Список формируется автоматически на основе того, какие поддерживаемые алгоритмы
 EncFS обнаружены в библиотеках шифрования. При использовании последней версии
 OpenSSL типичными вариантами являются Blowfish и AES.
 Blowfish — это 8-байтовый шифр, кодирующий 8 байтов за раз.
 AES — это 16-байтный шифр.
";ES;fi;;
  1) S=M1;SC; if [[ $cur == enter ]];then R;echo -e "
 Многие, если не все, поддерживаемые шифры поддерживают несколько длин ключей.
 На самом деле нет особой необходимости иметь огромные длины ключей.
 Даже 160 бит (по умолчанию), вероятно, слишком много.
";ES;fi;;
  2) S=M2;SC; if [[ $cur == enter ]];then R;echo -e "
 Это размер (в байтах), с которым работает EncFS за один раз.
 Каждый блок получает свой собственный вектор инициализации и кодируется в режиме
 цепочки блоков шифра. Частичный блок в конце файла кодируется с использованием
 потокового режима, чтобы избежать необходимости где-то хранить размер файла.
 Большие размеры блоков немного уменьшают накладные расходы EncFS, но также могут
 увеличить накладные расходы, если ваши программы читают небольшие части файлов.
 Чтобы прочитать один байт из файла, весь блок, содержащий этот байт, должен быть
 прочитан и декодирован, поэтому большой размер блока увеличивает нагрузку на
 небольшие запросы. С вызовами записи дело обстоит еще хуже, так как блок должен
 быть прочитан и декодирован, применено изменение, а блок закодирован и записан
 обратно. Значение по умолчанию — 512 байт, начиная с версии 1.0.
 В версии 0.x он был жестко запрограммирован на 64 байта,
 что было не так эффективно, как текущая настройка для общего использования.
";ES;fi;;
  3) S=M3;SC; if [[ $cur == enter ]];then R;echo -e "
 Новое в 1.1.
 Предоставляется выбор между потоковой кодировкой имени файла и блочной кодировкой.
 Преимущество потокового кодирования заключается в том, что закодированные имена
 файлов будут максимально короткими. Если у вас есть имя файла с одной буквой, оно
 будет очень коротким в закодированной форме, тогда как имена файлов с блочной
 кодировкой всегда округляются до размера блока шифровального шифра
 (8 байтов для Blowfish и 16 байтов для AES).
 Преимущество режима блочного кодирования заключается в том, что все длины имен
 файлов кратны размеру блока шифра. Это означает, что кто-то, кто просматривает
 ваши зашифрованные данные, не может ничего сказать о длине ваших имен файлов.
 Он включен по умолчанию, так как требует столько же времени, сколько и
 использование потокового шифра. Однако режим потокового шифрования может быть
 полезен, если по какой-то причине вам нужны более короткие зашифрованные имена
 файлов. Основываясь на базовой файловой системе, поддерживающей не более 255
 символов в именах файлов, вот максимально возможная длина имени файла в
 зависимости от выбранной схемы кодирования:
 поток (189), блок (176), блок 32 (143).
 Обратите внимание, что мы должны говорить скорее о байтах, когда имена файлов
 содержат специальные (многобайтовые) символы.
 До версии 1.1 поддерживалось только потоковое кодирование.
";ES;fi;;
  4) S=M4;SC; if [[ $cur == enter ]];then R;echo -e "
 Новое в 1.1.
 В предыдущих версиях EncFS каждый элемент имени файла в пути кодировался отдельно.
 Таким образом, если «foo» кодируется как «XXX», то он всегда будет кодироваться
 таким образом (с тем же ключом шифрования), независимо от того, был ли путь
 «a/b/foo» или «aa/foo/cc» и т. д. Это означало, что кто-то, просматривая
 зашифрованные данные, мог увидеть, имеют ли два файла в разных каталогах
 одно и то же имя, даже если он не знал, что это имя декодируется.
 При цепочке векторов инициализации каждый каталог получает свой собственный вектор
 инициализации. Таким образом, «a/foo» и «b/foo» будут иметь совершенно разные
 закодированные имена для «foo». Эта функция почти не влияет на производительность
 для большинства операций, и поэтому она используется по умолчанию во всех режимах.
 Примечание. Одним из существенных исключений производительности является
 переименование каталогов. Поскольку вектор инициализации для кодирования имени
 файла зависит от пути к каталогу, любое переименование требует повторного
 кодирования каждого имени файла в дереве изменяемого каталога. Если файлов тысячи,
 то EncFS придется делать тысячи переименований.
 Также возможно, что EncFS наткнется на файл, который не может декодировать
 или не имеет разрешения на перемещение во время операции переименования,
 и в этом случае она попытается отменить все изменения, сделанные до этого момента,
 и переименовать не удастся.
";ES;fi;;
  5) S=M5;SC; if [[ $cur == enter ]];then R;echo -e "
 Новое в 1.1. В предыдущих версиях EncFS каждый файл кодировался одинаково.
 Каждый блок в файле всегда имел свой собственный вектор инициализации,
 но детерминированным образом, так что блок N в одном файле кодировался так же,
 как блок N в другом файле. Это позволило кому-то определить, идентичны ли
 два файла (или идентичны ли части файла), сравнивая закодированные данные.
 С пофайловыми векторами инициализации каждый файл получает свой собственный
 64-битный случайный вектор инициализации, так что каждый файл шифруется по-своему.
 Эта опция включена по умолчанию. Обратный режим выводит IV из номера инода,
 затем он может измениться, например,
 при копировании исходных файлов из одной ФС в другую.
";ES;fi;;
  6) S=M6;SC; if [[ $cur == enter ]];then R;echo -e "
 Новое в версии 1.1.3. Этот параметр тесно связан с векторами инициализации для
 каждого файла и цепочкой векторов инициализации имен файлов. По сути, он расширяет
 цепочку векторов инициализации от имен файлов до вектора инициализации для каждого
 файла. Когда этот параметр включен, вектор инициализации для каждого файла
 кодируется с использованием вектора инициализации, полученного из кода цепочки
 векторов инициализации имени файла. Это означает, что данные в файле привязываются
 к имени файла. Если зашифрованный файл переименовывается вне encfs, он больше не
 будет декодироваться в encfs. Обратите внимание, что если заголовки Block MAC не
 включены, ошибка декодирования не будет обнаружена и приведет к считыванию
 случайных данных. С этим связаны затраты. Когда включена внешняя цепочка IV,
 жесткие ссылки не будут разрешены в файловой системе, поскольку не будет
 возможности правильно декодировать два разных имени файла, указывающих на одни и
 те же данные. Кроме того, переименование файла требует изменения заголовка файла.
 Таким образом, переименование будет разрешено только тогда, когда у пользователя
 есть права на запись в файл. Из-за этих ограничений этот параметр по умолчанию
 отключен для стандартного режима (и включен по умолчанию для режима паранойи).
 Эта опция может быть несовместима с некоторыми облачными провайдерами, так как
 при переименовании изменяется содержимое файла, но не его временная метка.
 Из-за этого изменения в файле могут неправильно отображаться программами
 синхронизации облачных провайдеров.
 В этом случае не рекомендуется использовать облако.
";ES;fi;;
  7) S=M7;SC; if [[ $cur == enter ]];then R;echo -e "
 Новое в 1.1. Если эта функция включена, каждый блок в каждом файле сохраняется
 вместе с криптографической контрольной суммой (код аутентификации сообщения).
 Это делает практически невозможным изменение файла без обнаружения изменения EncFS
 EncFS откажется читать данные, которые не проходят контрольную сумму,
 и зарегистрирует ошибку и вернет приложению ошибку ввода-вывода.
 Это добавляет существенные накладные расходы
 (по умолчанию 8 байт на блок файловой системы), а также вычислительные накладные
 расходы и не включено по умолчанию, за исключением режима паранойи. Когда это не
 включено и если EncFS запрашивается чтение измененных или поврежденных данных,
 у него не будет возможности проверить, являются ли декодированные данные теми,
 которые были изначально закодированы.
";ES;fi;;
  8) S=M8;SC; if [[ $cur == enter ]];then R;echo -e "
 Заставьте encfs оставлять дыры в файлах.
 Если блок читается как все нули, он будет считаться дырой и при чтении
 (не расшифрованном) останется с нулевыми значениями.
 Это необходимо при доступе к encfs по протоколу SMB.
 Включено по умолчанию. Можно отключить в экспертном режиме.
";ES;fi;;
  9) S=M9;SC;if [[ $cur == enter ]];then R;exit 0;fi;;
 esac;POS;done
