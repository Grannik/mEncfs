#!/bin/bash
 source "sEncfs.sh"
 UNMARK(){ $e "\e[0m";}
 MARK(){ $e "\e[30;47m";}
#
 HEAD()
{
 for (( a=2; a<=33; a++ ))
          do
              TPUT $a 1;$E "$ma"
          done
TPUT  1 1;$E "$mb"
TPUT  3 3;$E "\e[1;36m *** encfs ***\e[0m         Зашифрованная файловая система \e[36m Encrypted File System\e[0m";
TPUT  4 3;$E "\e[2m Mонтирует или создает зашифрованную виртуальную файловую систему\e[0m";
TPUT  5 1;$E "$mc"
TPUT 15 1;$E "$mc"
TPUT 17 1;$E "$mc"
TPUT 21 1;$E "$mc"
TPUT 22 3;$E "\e[2m В экспертном/ручном режиме конфигурации каждый из вышеперечисленных\e[0m";
TPUT 23 3;$E "\e[2m параметров настраивается.\e[0m";
TPUT 24 3;$E "\e[2m Вот список текущих опций с некоторыми примечаниями о том, что они означают:\e[0m";
TPUT 27 1;$E "$mc"
TPUT 29 1;$E "$mc"
TPUT 31 1;$E "$md"
}
 FOOT(){ MARK;TPUT 34 1;$E "$me";UNMARK;}
#
  M0(){ TPUT  6 3; $e " Установка                                                          \e[32m Install \e[0m";}
  M1(){ TPUT  7 3; $e " Kраткий обзор                                                     \e[32m Synopsis \e[0m";}
  M2(){ TPUT  8 3; $e " Описание                                                       \e[32m Description \e[0m";}
  M3(){ TPUT  9 3; $e " Автор                                                               \e[32m Author \e[0m";}
  M4(){ TPUT 10 3; $e " Смотрите также                                                    \e[32m See Also \e[0m";}
  M5(){ TPUT 11 3; $e " Переменные среды окружения                           \e[32m Environment Variables \e[0m";}
  M6(){ TPUT 12 3; $e " Предостережения                                                    \e[32m Caveats \e[0m";}
  M7(){ TPUT 13 3; $e " Отказ от ответственности                                        \e[32m Disclaimer \e[0m";}
  M8(){ TPUT 14 3; $e " Атаки, нападения                                                   \e[32m Attacks \e[0m";}
#
  M9(){ TPUT 16 3; $e " Параметры, Опции                                                   \e[36m Options \e[0m";}
#
 M10(){ TPUT 18 3; $e " Опции файловой системы                                  \e[32m Filesystem Options \e[0m";}
 M11(){ TPUT 19 3; $e " Режим использует следующие настройки:                             \e[32m Standard \e[0m";}
 M12(){ TPUT 20 3; $e " Режим используют следующие настройки:                             \e[32m Paranoia \e[0m";}
#
 M13(){ TPUT 25 3; $e " Функция вывода ключей                              \e[36m Key Derivation Function \e[0m";}
 M14(){ TPUT 26 3; $e " Порядок работы                                                             \e[32m \e[0m";}

 M15(){ TPUT 28 3; $e " Чтобы просмотреть точку монтирования                           \e[32m mount || df \e[0m";}

#
 M16(){ TPUT 30 3; $e " Git                                                                         ";}
#
 M17(){ TPUT 32 3; $e " Exit                                                                        ";}
LM=17
   MENU(){ for each in $(seq 0 $LM);do M${each};done;}
    POS(){ if [[ $cur == up ]];then ((i--));fi
           if [[ $cur == dn ]];then ((i++));fi
           if [[ $i -lt 0   ]];then i=$LM;fi
           if [[ $i -gt $LM ]];then i=0;fi;}
REFRESH(){ after=$((i+1)); before=$((i-1))
           if [[ $before -lt 0  ]];then before=$LM;fi
           if [[ $after -gt $LM ]];then after=0;fi
           if [[ $j -lt $i      ]];then UNMARK;M$before;else UNMARK;M$after;fi
           if [[ $after -eq 0 ]] || [ $before -eq $LM ];then
           UNMARK; M$before; M$after;fi;j=$i;UNMARK;M$before;M$after;}
   INIT(){ R;HEAD;FOOT;MENU;}
     SC(){ REFRESH;MARK;$S;$b;cur=`ARROW`;}
# Функция возвращения в меню
     ES(){ MARK;$e " ENTER = main menu ";$b;read;INIT;};INIT
  while [[ "$O" != " " ]]; do case $i in
  0) S=M0;SC; if [[ $cur == enter ]];then R;echo -e "
 \e[32m sudo apt install encfs\e[0m
 или
 \e[32m sudo apt-get install encfs libpam-encfs\e[0m
 При установке появится сообщение. Нажать\e[32m OK\e[0m
";ES;fi;;
  1) S=M1;SC; if [[ $cur == enter ]];then R;echo -e "\e[32m
 encfs
 [--version] [-v|--verbose] [-c|--config] [-t|--syslogtag] [-s] [-f] [--annotate]
 [--standard] [--paranoia] [--insecure] [--reverse] [--reversewrite] [--anykey]
 [--extpass=program] [-S|--stdinpass] [--forcedecode] [-require-macs] [--nocache]
 [-i MINUTES|--idle=MINUTES] [-m|--ondemand] [--delaymount] [--no-default-flags]
 [-u|--unmount] [--public] [--noattrcache] [--nodatacache] [-o FUSE_OPTION]
 [-d|--fuse-debug] [-H|--fuse-help] rootdir mountPoint [-- [Fuse Mount Options]]
\e[0m";ES;fi;;
  2) S=M2;SC; if [[ $cur == enter ]];then R;echo -e "
 В терминале OS Linux можно зашифровать директории, используя утилиту encfs
 Наиболее простой и эффективный способ создания зашифрованного раздела (папки)
 для ваших файлов – это использовать fuse.
 Fuse – модуль ядра, позволяющий пользователям создавать свои собственные локальные
 файловые системы, в своём домашнем каталоге или на USB.
 Encfs создает зашифрованную виртуальную файловую систему на основе не
 зашифрованной файловой системы которая хранит зашифрованные данные в каталоге
 rootdir и делает незашифрованные данные видимыми в каталоге mountPoint.
 Зашифрованные данные сохраняются в специальном каталоге, который можно монтировать
 как обычный каталог и работать с ним, как с обычным каталогом.
 Пользователь должен указать пароль, который используется для (косвенного)
 шифрования как имен файлов, так и их содержимого.
 Если EncFS не может найти поддерживаемую файловую систему в указанном корневом
 каталоге, пользователю будет предложено создать новую зашифрованную файловую
 систему в указанном месте. Пользователю будут представлены параметры,
 позволяющие некоторый контроль над используемыми алгоритмами.
 Когда каталог размонтируется, зашифрованные данные автоматически зашифруются.
 По мере развития EncFS количество вариантов может увеличиваться.
";ES;fi;;
  3) S=M3;SC; if [[ $cur == enter ]];then R;echo -e "
 EncFS was written by Valient Gough:\e[36m vgough@pobox.com\e[0m
 Site:\e[36m https://vgough.github.io/encfs/\e[0m
 Support, bug reports... :\e[36m https://github.com/vgough/encfs\e[0m
 Mailing list: none.
 Главный сайт:\e[36m https://encfsmp.sourceforge.io/index.html\e[0m
 Cygwin, Windows ports:\e[36m https://github.com/vgough/encfs/wiki\e[0m
";ES;fi;;
  4) S=M4;SC; if [[ $cur == enter ]];then R;echo -e "
\e[32m encfsctl\e[0m
";ES;fi;;
  5) S=M5;SC; if [[ $cur == enter ]];then R;echo -e "
\e[32m ENCFS6_CONFIG\e[0m
 Какой файл конфигурации (обычно с именем .encfs6.xml) использовать.
 По умолчанию файл конфигурации читается из зашифрованного каталога.
 Использование этой опции позволяет хранить файл конфигурации отдельно от
 зашифрованных файлов.
 Предупреждение: Если вы потеряете файл конфигурации, зашифрованное содержимое
 файла будет безвозвратно утеряно. Он содержит мастер-ключ, зашифрованный вашим
 паролем. Без мастер-ключа восстановление невозможно, даже если вы знаете пароль.
 отредактировать файл:
\e[32m sudo ne /etc/security/pam_encfs.conf\e[0m
 и файл:
\e[32m sudo ne /etc/fuse.conf\e[0m
";ES;fi;;
  6) S=M6;SC; if [[ $cur == enter ]];then R;echo -e "
 EncFS не является настоящей файловой системой.
 Он не касается фактического хранения или обслуживания файлов.
 Он просто транслирует запросы (при необходимости шифруя или расшифровывая)
 и передает запросы базовой файловой системе хоста.
 Поэтому любые ограничения файловой системы хоста будут унаследованы EncFS
 (или, возможно, будут дополнительно ограничены).
 Одним из таких ограничений является длина имени файла.
 Если ваша базовая файловая система ограничивает вас N символами в имени файла,
 то EncFS ограничит вас примерно 3*(N-2)/4.
 Например, если файловая система хоста ограничивается 255 символами,
 то EncFS будет ограничена 189-символьными именами файлов.
 Это связано с тем, что зашифрованные имена файлов всегда длиннее,
 чем имена файлов в виде открытого текста.
";ES;fi;;
  7) S=M7;SC; if [[ $cur == enter ]];then R;echo -e "
 Эта библиотека распространяется в надежде, что она будет полезна, но
 БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ; даже без подразумеваемой гарантии КОММЕРЧЕСКОЙ
 ПРИГОДНОСТИ или ПРИГОДНОСТИ ДЛЯ ОПРЕДЕЛЕННОЙ ЦЕЛИ.
 Пожалуйста, обратитесь к файлу\e[32m COPYING\e[0m,
 распространяемому вместе с EncFS, для получения полной информации.
";ES;fi;;
  8) S=M8;SC; if [[ $cur == enter ]];then R;echo -e "
 Основная цель EncFS — защита данных в автономном режиме.
 То есть предоставить удобный способ хранения файлов таким образом, чтобы
 предотвратить любую попытку их чтения, если файлы впоследствии будут перехвачены.
 Некоторые алгоритмы в EncFS также предназначены для предотвращения онлайн-атак,
 когда предполагается, что злоумышленник может изменить файлы.
 Наиболее интрузивные атаки, когда злоумышленник имеет полный контроль над
 компьютером пользователя (и, следовательно, может модифицировать EncFS, FUSE или
 само ядро), не защищены от них. Не думайте, что зашифрованные файлы защитят ваши
 конфиденциальные данные, если вы введете свой пароль на скомпрометированном
 компьютере. Как определить, что компьютер безопасен для использования,
 не рассматривается в этой документации. Тем не менее, вот несколько примеров атак
 и методов сбора данных о содержимом файловой системы, а также алгоритмы,
 которые EncFS поддерживает для их предотвращения:
\e[32m Attacks\e[0m изменение нескольких байтов зашифрованного файла (не зная, во что они
 будут декодированы).
 EncFS не использует какую-либо форму шифрования XOR, которая позволяла бы изменять
 отдельные байты, не затрагивая другие. Большинство модификаций затрагивают десятки
 и более байтов. Кроме того, заголовки блоков MAC можно использовать для
 идентификации любых изменений в файлах.
\e[32m Attacks\e[0m копирование случайного блока одного файла в случайный блок другого файла.
 Каждый блок имеет свой [детерминированный] вектор инициализации.
\e[32m Attacks\e[0m копирование блока N в блок N другого файла.
 Когда включена поддержка вектора инициализации для каждого файла
 (по умолчанию в файловых системах 1.1.x), скопированный блок не будет правильно
 декодироваться при копировании в другой файл.
\e[32m Attacks\e[0m копирование всего файла в другой файл.
 Можно предотвратить, включив режим внешней цепочки IV.
\e[32m Attacks\e[0m определить, являются ли два имени файла одинаковыми,
 просмотрев зашифрованные имена. Цепочка векторов инициализации имени файла
 предотвращает это, предоставляя каждому файлу 64-битный вектор инициализации,
 полученный из его полного имени пути.
\e[32m Attacks\e[0m сравнить, если два файла содержат одинаковые данные.
 Поддержка вектора инициализации для каждого файла предотвращает это.
";ES;fi;;
  9) S=M9;SC;if [[ $cur == enter ]];then R;./nEncfsOptions.sh;ES;fi;;
 10) S=M10;SC; if [[ $cur == enter ]];then R;echo -e "
 Когда EncFS предоставляется корневой каталог, который не содержит существующей
 файловой системы EncFS, он дает возможность создать ее. Обратите внимание,
 что параметры могут быть установлены только во время создания файловой системы.
 Не поддерживается изменение параметров файловой системы на месте.
 Если вы хотите обновить файловую систему, чтобы использовать новые функции,
 вам нужно создать новую файловую систему и одновременно смонтировать старую и
 новую файловую систему и скопировать старую в новую. Одновременно можно
 запускать несколько экземпляров encfs, включая разные версии encfs, если они
 совместимы с текущим модулем FUSE в вашей системе. На выбор предоставляется два
 предварительно настроенных параметра («стандартный» и «паранойя»),
 а также экспертный режим настройки.
";ES;fi;;
 11) S=M11;SC;if [[ $cur == enter ]];then R;echo -e "
 Стандартный режим использует следующие настройки:

 Cipher: AES
 Key Size: 192 bits
 PBKDF2 with 1/2 second runtime, 160 bit salt
 Filesystem Block Size: 1024 bytes
 Filename Encoding: Block encoding with IV chaining
 Unique initialization vector file headers
 File holes passed through

 Шифр: AES
 Размер ключа: 192 бита
 PBKDF2 с временем выполнения 1/2 секунды, 160-битная соль
 Размер блока файловой системы: 1024 байта
 Кодирование имени файла: блочное кодирование с цепочкой IV
 Уникальные заголовки векторных файлов инициализации
 Отверстия в файлах пройдены
";ES;fi;;
 12) S=M12;SC;if [[ $cur == enter ]];then R;echo -e "
 В режиме Paranoia используются следующие настройки:
 Cipher: AES
 Key Size: 256 bits
 PBKDF2 with 3 second runtime, 160 bit salt
 Filesystem Block Size: 1024 bytes
 Filename Encoding: Block encoding with IV chaining
 Unique initialization vector file headers
 Message Authentication Code block headers
 External IV Chaining
 File holes passed through

 Шифр: AES
 Размер ключа: 256 бит
 PBKDF2 с 3-секундным временем выполнения, 160-битная соль
 Размер блока файловой системы: 1024 байта
 Кодирование имени файла: блочное кодирование с цепочкой IV
 Уникальные заголовки векторных файлов инициализации
 Заголовки блока кода аутентификации сообщения
 Внешняя цепочка IV
 Отверстия в файлах пройдены
";ES;fi;;
 13) S=M13;SC;if [[ $cur == enter ]];then R;./nEncfsDerivation.sh;ES;fi;;
 14) S=M14;SC;if [[ $cur == enter ]];then R;echo -e "
 Порядок работы:
 1. Проверьте наличие encfs а на вашей системе.
 2. Установите encfs, если она еще не установлена на вашей системе.
 3. Создайте каталог, в котором будут храниться зашифрованные данные.
 Например, для создания каталога с именем encrypted выполните следующую команду:
\e[32m mkdir ~/encrypted\e[0m
 4. Создайте каталог, который вы хотите зашифровать.
 Например, для создания каталога с именем decrypted выполните следующую команду:
\e[32m mkdir ~/decrypted\e[0m
 5. Запустите команду encfs и введите путь к каталогу с незашифрованными данными:
 (~/decrypted) и путь к каталогу с зашифрованными данными (~/encrypted).
 Вам будет предложено задать пароль для зашифрованной файловой системы:
\e[32m encfs ~/encrypted ~/decrypted\e[0m
 Выбрана стандартная конфигурация.
 Использование шифра Blowfish, размер ключа 160, размер блока 512
 Новый пароль: <здесь вводится пароль> Подтверждение: <здесь вводится пароль>
 После ввода пароля, зашифрованная файловая система будет создана и монтирована.
 6. Теперь вы можете работать с каталогом decrypted как с обычным каталогом,
 и все данные, которые помещаются в этот каталог, будут автоматически зашифрованы.
 7. Закончив работу с зашифрованными данными, не забудьте выйти из директории
 и размонтируйте их с помощью oпции\e[32m -u\e[0m.
 8. Если вы хотите заново работать с этими данными, выполните команду encfs.
 Обратите внимание, что при использовании encfs важно хранить пароль в безопасном
 месте и не допускать его утечки.
";ES;fi;;
 15) S=M15;SC;if [[ $cur == enter ]];then R;echo -e "
\e[32m mount | grep ~/decrypted\e[0m
или
\e[32m df -h | grep ~/decrypted\e[0m
";ES;fi;;
#
 16) S=M16;SC;if [[ $cur == enter ]];then R;echo -e "
 Mi 08 Mär 2023 22:22:36 CET
 mEncfs Описание утилиты encfs Зашифрованная файловая система.
 Mонтирует или создает зашифрованную виртуальную файловую систему.
 Asciinema:  \e[36m https://asciinema.org/a/2Ft5oBZP1P0Gc6610Mw60Tifm\e[0m
 Codeberg:   \e[36m https://codeberg.org/Grannik/mEncfs\e[0m
 Github:     \e[36m \e[0m
 Gitlab:     \e[36m \e[0m
 Sourceforge:\e[36m \e[0m
 Notabug:    \e[36m \e[0m
 Bitbucket:  \e[36m \e[0m
 Framagit:   \e[36m \e[0m
 GFogs:      \e[36m \e[0m
 Gitea       \e[36m \e[0m
 ~~~ File ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Phacility:  \e[36m \e[0m
 Archive:    \e[36m \e[0m
 Discord:    \e[36m \e[0m
 Mewe:       \e[36m \e[0m
 ~~~ Post ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Bastyon:\e[36m \e[0m
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Peergos:\e[36m \e[0m
";ES;fi;;
 17) S=M17;SC;if [[ $cur == enter ]];then R;clear;ls -l;exit 0;fi;;
 esac;POS;done
