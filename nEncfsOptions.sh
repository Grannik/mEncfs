#!/bin/bash
source "sEncfs.sh"
# это цвет текста списка перед курсором при значении 0 в переменной  UNMARK(){ $e "\e[0m";}
 UNMARK(){ $e "\e[0m";}
 MARK(){ $e "\e[1;37m";}
#
 HEAD()
{
 for (( a=2; a<=35; a++ ))
  do
   TPUT $a 1
    $E "$na";
  done
   TPUT  1 1;$E "$nb";UNMARK;
   TPUT  2 3;$E "Параметры, Опции                                                    \e[36m Options\e[0m";
   TPUT  3 1;$E "$nc";
   TPUT 34 1;$E "$nd";
}
 FOOT(){ MARK;TPUT 36 1;$E "$ne";UNMARK;}
#
  M0(){ TPUT  4 3; $e "Показывает версию EncFS                                           \e[32m --version \e[0m";}
  M1(){ TPUT  5 3; $e "Заставляет EncFS использовать предоставленный файл              \e[32m -c --config \e[0m";}
  M2(){ TPUT  6 3; $e "Заставляет EncFS включить ведение журнала различных каналов    \e[32m -v --verbose \e[0m";}
  M3(){ TPUT  7 3; $e "Эта опция позволяет установить тег системного журнала        \e[32m -t --syslogtag \e[0m";}
  M4(){ TPUT  8 3; $e "Параметр заставляет EncFS работать в однопоточном режиме                 \e[32m -s \e[0m";}
  M5(){ TPUT  9 3; $e "Параметр заставляет EncFS работать в приоритетном режиме                 \e[32m -f \e[0m";}
  M6(){ TPUT 10 3; $e "Печатать строки аннотаций в stderr во время настройки            \e[32m --annotate \e[0m";}
  M7(){ TPUT 11 3; $e "Aвтоматически выбираются стандартные параметры                   \e[32m --standard \e[0m";}
  M8(){ TPUT 12 3; $e "То же, что и --standard, но для режима паранойи                  \e[32m --paranoia \e[0m";}
  M9(){ TPUT 13 3; $e "B качестве исходных данных используются открытые текстовые данные\e[32m --insecure \e[0m";}

 M10(){ TPUT 14 3; $e "Oбратное шифрование                                                \e[32m --revers \e[0m";}

 M11(){ TPUT 15 3; $e "То же, что и --reverse, но разрешает запись, если возможно   \e[32m --reversewrite \e[0m";}
 M12(){ TPUT 16 3; $e "Укажите внешнюю программу получения пароля пользователя   \e[32m --extpass=program \e[0m";}
 M13(){ TPUT 17 3; $e "Чтение пароля из стандартного ввода без запроса              \e[32m -S --stdinpass \e[0m";}
 M14(){ TPUT 18 3; $e "Отключите проверку проверки ключа                                  \e[32m --anykey \e[0m";}
 M15(){ TPUT 19 3; $e "Bлияет на файловые системы, используют заголовки блоков MAC   \e[32m --forcedecode \e[0m";}
 M16(){ TPUT 20 3; $e "Принудительно включает заголовки блочного кода аутентификации\e[32m --require-macs \e[0m";}
 M17(){ TPUT 21 3; $e "Включите автоматическое размонтирование файловой системы  \e[32m -i --idle=MINUTES \e[0m";}
 M18(){ TPUT 22 3; $e "Монтируйте файловую систему по требованию                     \e[32m -m --ondemand \e[0m";}
 M19(){ TPUT 23 3; $e "Не монтируйте файловую систему при запуске encfs               \e[32m --delaymount \e[0m";}
 M20(){ TPUT 24 3; $e "Размонтирует указанную точку монтирования                      \e[32m -u --unmount \e[0m";}
 M21(){ TPUT 25 3; $e "encfs как типичная многопользовательская файловая система          \e[32m --public \e[0m";}
 M22(){ TPUT 26 3; $e "Отключите кеш ядра файловых атрибутов                             \e[32m --nocache \e[0m";}
 M23(){ TPUT 27 3; $e "То же, что --nocache, но только для атрибутов                 \e[32m --noattrcache \e[0m";}
 M24(){ TPUT 28 3; $e "То же, что --nocache, но только для атрибутов                 \e[32m --nodatacache \e[0m";}
 M25(){ TPUT 29 3; $e "Encfs добавляет флаги FUSE use_ino и default_permissions \e[32m --no-default-flags \e[0m";}
 M26(){ TPUT 30 3; $e "Передайте аргументы FUSE базовой библиотеке                     \e[32m -o FUSE_ARG \e[0m";}
 M27(){ TPUT 31 3; $e "Включает отладку в библиотеке FUSE                          \e[32m -d --fuse-debug \e[0m";}
 M28(){ TPUT 32 3; $e "Shows FUSE help                                              \e[32m -H --fuse-help \e[0m";}
 M29(){ TPUT 33 3; $e "все оставшиеся аргументы следует отправить непосредственно в FUSE        \e[32m -- \e[0m";}
#
 M30(){ TPUT 35 3; $e "                                                                       \e[32m Exit \e[0m";}
LM=30
   MENU(){ for each in $(seq 0 $LM);do M${each};done;}
    POS(){ if [[ $cur == up ]];then ((i--));fi
           if [[ $cur == dn ]];then ((i++));fi
           if [[ $i -lt 0   ]];then i=$LM;fi
           if [[ $i -gt $LM ]];then i=0;fi;}
REFRESH(){ after=$((i+1)); before=$((i-1))
           if [[ $before -lt 0  ]];then before=$LM;fi
           if [[ $after -gt $LM ]];then after=0;fi
           if [[ $j -lt $i      ]];then UNMARK;M$before;else UNMARK;M$after;fi
           if [[ $after -eq 0 ]] || [ $before -eq $LM ];then
           UNMARK; M$before; M$after;fi;j=$i;UNMARK;M$before;M$after;}
   INIT(){ R;HEAD;FOOT;MENU;}
     SC(){ REFRESH;MARK;$S;$b;cur=`ARROW`;}
# Функция возвращения в меню
     ES(){ MARK;$e " ENTER = main menu ";$b;read;INIT;};INIT
  while [[ "$O" != " " ]]; do case $i in
  0) S=M0;SC; if [[ $cur == enter ]];then R;echo -e "
 Показывает версию EncFS:\e[32m encfs --version\e[0m
 Использование --verbose перед --version может отображать дополнительную информацию
";ES;fi;;
  1) S=M1;SC; if [[ $cur == enter ]];then R;echo -e "
 Заставляет EncFS использовать предоставленный файл в качестве файла конфигурации.
\e[32m encfs --config\e[0m или\e[32m encfs --config\e[0m
";ES;fi;;
  2) S=M2;SC; if [[ $cur == enter ]];then R;echo -e "
 Заставляет EncFS включить ведение журнала различных каналов отладки в EncFS.
\e[32m encfs -v\e[0m или\e[32m encfs --verbose\e[0m
 Обычно эти сообщения регистрации отключены и не действуют.
 Рекомендуется запускать в режиме переднего плана (-f)
 при работе с включенным подробным описанием.
 Если вы обнаружите странное поведение в какой-то конкретной программе при
 работе в зашифрованной файловой системе, может быть полезно запустить в подробном
 режиме при воспроизведении проблемы и отправить вывод с отчетом о проблеме:
\e[32m encfs -v -f ~/.crypt ~/crypt 2> encfs-report.txt\e[0m
";ES;fi;;
  3) S=M3;SC; if [[ $cur == enter ]];then R;echo -e "
 Эта опция позволяет установить тег системного журнала, который будет
 использоваться при регистрации сообщений через системный журнал:
\e[32m encfs -t\e[0m или\e[32m encfs --syslogtag\e[0m
 По умолчанию для тега системного журнала установлено значение encfs.
";ES;fi;;
  4) S=M4;SC; if [[ $cur == enter ]];then R;echo -e "
 Параметр -s (однопоточный) заставляет EncFS работать в однопоточном режиме.
 По умолчанию EncFS работает в многопоточном режиме.
 Эта опция используется во время разработки EncFS, чтобы упростить отладку
 и позволить ей работать с инструментами проверки памяти.
\e[32m encfs -s\e[0m
";ES;fi;;
  5) S=M5;SC; if [[ $cur == enter ]];then R;echo -e "
 Параметр -f (передний план) заставляет EncFS работать в приоритетном режиме.
 Обычно EncFS запускается как демон и работает в фоновом режиме,
 возвращая управление порождающей оболочке.
 С параметром -f он будет работать на переднем плане, и любые сообщения журнала
 предупреждений/отладки будут отображаться при стандартной ошибке. В режиме по
 умолчанию (фоновом) все сообщения журнала регистрируются через системный журнал.
\e[32m encfs -f\e[0m
";ES;fi;;
  6) S=M6;SC; if [[ $cur == enter ]];then R;echo -e "
 Печатать строки аннотаций в stderr во время настройки:
\e[32m encfs --annotate\e[0m
";ES;fi;;
  7) S=M7;SC; if [[ $cur == enter ]];then R;echo -e "
 При создании новой файловой системы автоматически выбираются стандартные
 параметры конфигурации, чтобы облегчить автоматическое создание файловой системы:
\e[32m encfs --standard\e[0m
 Это набор параметров, которые следует использовать,
 если вы не знаете, что делаете, и не читали документацию.
 Если файловая система не создается, этот флаг ничего не делает.
";ES;fi;;
  8) S=M8;SC; if [[ $cur == enter ]];then R;echo -e "
 То же, что и --standard, но для режима паранойи:\e[32m encfs --paranoia\e[0m
";ES;fi;;
  9) S=M9;SC; if [[ $cur == enter ]];then R;echo -e "
 Обычно EncFS обеспечивает представление данных в виде открытого текста по запросу
 он хранит зашифрованные данные и отображает данные в виде открытого текста:
\e[32m encfs --insecure\e[0m
 С параметром --reverse в качестве исходных данных используются открытые текстовые
 данные, а по запросу создаются зашифрованные данные. Это может быть полезно для
 создания удаленных зашифрованных резервных копий, когда вы не хотите оставлять
 локальные файлы незашифрованными.
 Например, следующий код создаст зашифрованное представление в /tmp/crypt-view
\e[32m encfs --reverse /home/me /tmp/crypt-view\e[0m
 Затем вы можете скопировать каталог /tmp/crypt-view, чтобы получить копию
 зашифрованных данных. Вы также должны сохранить копию файла /home/me/.encfs6.xml,
 который содержит информацию о файловой системе. Вместе они могут использоваться
 для воспроизведения незашифрованных данных:
\e[32m ENCFS6_CONFIG=/home/me/.encfs6.xml encfs /tmp/crypt-view /tmp/plain-view\e[0m
 Теперь /tmp/plain-view содержит те же данные, что и /home/me
 Обратите внимание, что режим --reverse работает только с ограниченными параметрами
 конфигурации, поэтому при использовании многие параметры могут быть отключены.
 Несовместимые параметры на данный момент:
 Цепочка векторов инициализации имени файла и Внешняя цепочка IV.
";ES;fi;;
 10) S=M10;SC;if [[ $cur == enter ]];then R;echo -e "
 обратное шифрование
";ES;fi;;
 11) S=M11;SC;if [[ $cur == enter ]];then R;echo -e "
 То же, что и --reverse, но разрешает запись, если это возможно
 (в конфигурации должен быть отключен UniqueIV).
 Несовместимый вариант: Векторы инициализации для каждого файла.
";ES;fi;;
 12) S=M12;SC;if [[ $cur == enter ]];then R;echo -e "
 Укажите внешнюю программу для получения пароля пользователя.
 При запуске внешней программы переменная окружения RootDir будет содержать путь
 к корневому каталогу. Программа должна вывести пароль на стандартный вывод.
 EncFS принимает за пароль все, что возвращает программа, за исключением символа
 новой строки в конце (\\\n), который будет удален. Например, указание:
\e[32m --extpass=/usr/lib/ssh/ssh-askpass\e[0m
 заставит EncFS использовать программу запроса пароля ssh.
 Примечание. EncFS считывает не более 2КБ данных из программы паролей и удаляет
 все завершающие символы новой строки.
 Версии до 1.4.x принимали только 64 байта текста.
";ES;fi;;
 13) S=M13;SC;if [[ $cur == enter ]];then R;echo -e "
 Чтение пароля из стандартного ввода без запроса.
 Это может быть полезно для сценариев монтирования encfs.
 Обратите внимание, что вы должны сначала убедиться, что файловая система и точки
 монтирования существуют. В противном случае encfs запросит параметры создания
 файловой системы, что может помешать вашему сценарию.
\e[32m encfs -S\e[0m или\e[32m encfs --stdinpass\e[0m
";ES;fi;;
 14) S=M14;SC;if [[ $cur == enter ]];then R;echo -e "
 Отключите проверку проверки ключа:
\e[32m encfs --anykey\e[0m
 Это позволяет использовать EncFS со вторичными паролями.
 Это можно использовать для хранения отдельного набора файлов в зашифрованной
 файловой системе. EncFS игнорирует файлы, которые не декодируются должным образом,
 поэтому файлы, созданные с отдельными паролями, будут видны только тогда, когда
 файловая система смонтирована с соответствующим паролем. Обратите внимание, что
 если основной пароль изменен (с помощью encfsctl), другие пароли нельзя будет
 использовать, если только основной пароль не будет установлен обратно в то
 состояние, в котором он был, поскольку другие пароли основаны на недопустимом
 декодировании ключа громкости, который не останется. то же самое,
 если основной пароль изменен.
 Предупреждение: используйте эту опцию на свой страх и риск.
";ES;fi;;
 15) S=M15;SC;if [[ $cur == enter ]];then R;echo -e "
 Эта опция влияет только на файловые системы,
 которые используют заголовки блоков MAC.
 По умолчанию, если блок декодирован, а сохраненный MAC-адрес не соответствует
 рассчитанному, то приложению возвращается ошибка ввода-вывода, и блок не
 возвращается. Однако при указании --forcedecode будет зарегистрирована только
 ошибка, а данные все равно будут возвращены в приложение.
 Это может быть полезно при попытке чтения поврежденных файлов.
\e[32m encfs --forcedecode\e[0m
";ES;fi;;
 16) S=M16;SC;if [[ $cur == enter ]];then R;echo -e "
 При создании новой файловой системы это принудительно включает заголовки блочного
 кода аутентификации. При монтировании существующей файловой системы это приводит к
 завершению работы encfs, если не включены заголовки блочного кода аутентификации.
 Это можно использовать для повышения безопасности в случае, если зашифрованный
 текст уязвим для подделки, не позволяя злоумышленнику отключить MAC-адреса
 в файле конфигурации.\e[32m encfs --require-macs\e[0m
";ES;fi;;
 17) S=M17;SC;if [[ $cur == enter ]];then R;echo -e "
 Включите автоматическое размонтирование файловой системы после периода бездействия
\e[32m encfs -i\e[0m или\e[32m encfs --idle=MINUTES\e[0m
 Период указывается в минутах, поэтому самый короткий период ожидания,
 который может быть запрошен, составляет одну минуту.
 EncFS не будет автоматически размонтироваться, если в файловой системе есть
 открытые файлы, даже если они открыты в режиме только для чтения.
 Однако простое открытие файлов не считается активностью.
";ES;fi;;
 18) S=M18;SC;if [[ $cur == enter ]];then R;echo -e "
 Монтируйте файловую систему по требованию:\e[32m encfs \e[0m или\e[32m encfs \e[0m
 В настоящее время это имеет смысл только в сочетании с параметрами --idle
 и --extpass. Когда файловая система становится бездействующей, вместо выхода EncFS
 прекращает разрешать доступ к файловой системе, внутренне удаляя свою ссылку на
 нее. Если кто-то снова попытается получить доступ к файловой системе, программа
 extpass запросит у пользователя пароль.
 Если это удается, то файловая система снова становится доступной.
";ES;fi;;
 19) S=M19;SC;if [[ $cur == enter ]];then R;echo -e "
 Не монтируйте файловую систему при запуске encfs.
 Вместо этого отложите монтаж до первого использования.
 Эта опция имеет смысл только с --ondemand.
";ES;fi;;
 20) S=M20;SC;if [[ $cur == enter ]];then R;echo -e "
 Закончив работу с зашифрованными данными, размонтируйте их с помощью команды:
 \e[32m fusermount -u ~/decrypted\e[0m
 или
 \e[32m fusermount --unmount ~/decrypted\e[0m
 Эти команды размонтируют зашифрованную файловую систему.
";ES;fi;;
 21) S=M21;SC;if [[ $cur == enter ]];then R;echo -e "
 Попытайтесь заставить encfs вести себя как типичная многопользовательская файловая
 система. По умолчанию все файловые системы на базе FUSE видны только тому
 пользователю, который их смонтировал. Никакие другие пользователи (включая root)
 не могут просматривать содержимое файловой системы. Опция --public делает две вещи
 Он добавляет флаги FUSE «allow_other» и «default_permission» при монтировании
 файловой системы, которые сообщают FUSE разрешить другим пользователям доступ к
 файловой системе и использовать права владения, предоставляемые файловой системой.
 Во-вторых, флаг --public меняет то, как работают функции создания узлов encfs,
 поскольку они будут пытаться установить права собственности на новые узлы
 на основе идентификации вызывающей стороны.
 Предупреждение: чтобы это работало, encfs должен быть запущен от имени
 пользователя root, иначе у него не будет возможности изменить владельца файлов.
 Вместо этого я рекомендую вам выяснить, можно ли использовать опцию
 fuse allow_other для того, что вы хотите,
 прежде чем рассматривать возможность использования --public.
";ES;fi;;
 22) S=M22;SC;if [[ $cur == enter ]];then R;echo -e "
 Отключите кеш ядра файловых атрибутов.
 Установка этого параметра заставляет EncFS передавать
 'attr_timeoutu003d0' и 'entry_timeoutu003d0' в FUSE.
 Это гарантирует, что изменения атрибутов резервного файла, происходящие за
 пределами EncFS, немедленно отобразятся при монтировании EncFS.
 Внутренний кэш данных EncFS также отключен.
 Основным вариантом использования --nocache является обратный режим.
";ES;fi;;
 23) S=M23;SC;if [[ $cur == enter ]];then R;echo -e "
 То же, что --nocache, но только для атрибутов
";ES;fi;;
 24) S=M24;SC;if [[ $cur == enter ]];then R;echo -e "
 То же, что --nocache, но только для атрибутов
";ES;fi;;
 25) S=M25;SC;if [[ $cur == enter ]];then R;echo -e "
 Encfs добавляет флаги FUSE\e[32m use_ino\e[0m и\e[32m default_permissions\e[0m по умолчанию,
 начиная с версии 1.2.2, потому что это улучшает совместимость с некоторыми
 программами. Если по какой-то причине вам нужно отключить один или оба этих флага,
 используйте опцию --no-default-flags.
 Следующие командные строки дают тот же результат:
\e[32m encfs raw crypt
 encfs --no-default-flags raw crypt -- -o use_ino,default_permissions
\e[0m";ES;fi;;
 26) S=M26;SC;if [[ $cur == enter ]];then R;echo -e "
 Передайте аргументы FUSE базовой библиотеке.
 Это упрощает передачу опций FUSE при монтировании EncFS
 через mount (и /etc/fstab). Например:
\e[32m mount encfs#/home/me-crypt /home/me -t fuse -o kernel_cache\e[0m
 Обратите внимание, что аргументы encfs не могут быть установлены таким образом.
 Если вам нужно установить аргументы encfs, создайте оболочку,
 такую как encfs-reverse:
\e[32m #!/bin/sh
 encfs --reverse \"\$@\"\e[0m
 Затем смонтируйте, используя путь сценария:
\e[32m mount encfs-reverse#/home/me /home/me-crypt -t fuse\e[0m
";ES;fi;;
 27) S=M27;SC;if [[ $cur == enter ]];then R;echo -e "
 Включает отладку в библиотеке FUSE.
 Это следует использовать только в том случае, если вы подозреваете проблему
 в самом FUSE (не в EncFS), так как он генерирует много низкоуровневых данных
 и вряд ли будет очень полезен для общего отслеживания проблем.
 Сначала попробуйте подробный режим (-v),
 который дает представление более высокого уровня о том, что происходит в EncFS.
";ES;fi;;
 28) S=M28;SC;if [[ $cur == enter ]];then R;echo -e "
 Shows FUSE help:
\e[32m encfs -H\e[0m или\e[32m encfs --fuse-help\e[0m
";ES;fi;;
 29) S=M29;SC;if [[ $cur == enter ]];then R;echo -e "
 Параметр -- сообщает EncFS, что все оставшиеся аргументы следует отправить
 непосредственно в FUSE. В свою очередь, FUSE передает аргументы функции fusermount
 Информацию о доступных командах см. на странице справки fusermount.
 Другой пример. Чтобы смонтировать ту же файловую систему, но с именем fusermount
 для точки монтирования '/dev/foo' (как показано в df и других инструментах,
 которые читают /etc/mtab), а также запросить кэширование файловых данных на уровне
 ядра (оба являются специальными аргументы для fusermount):
\e[32m encfs ~/.crypt ~/crypt -- -n /dev/foo -c\e[0m
";ES;fi;;
 30) S=M30;SC;if [[ $cur == enter ]];then R;exit 0;fi;;
 esac;POS;done
